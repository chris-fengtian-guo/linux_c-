From e0522ab6bdd7fee1330b5ad96b1a2d6038f2b50a Mon Sep 17 00:00:00 2001
From: nathan <nathan@dorkbox.com>
Date: Thu, 8 Jan 2015 22:21:58 +0100
Subject: [PATCH 1/5] Added BARCHART 2013-05-11 (2013-05-12 already applied)
 patch to source

---
 JavaLauncherApp/src/udt/api.cpp       |  85 +++-
 JavaLauncherApp/src/udt/api.h         |   5 +
 JavaLauncherApp/src/udt/ccc.cpp       |   4 +-
 JavaLauncherApp/src/udt/common.cpp    | 765 ----------------------------------
 JavaLauncherApp/src/udt/common.h      | 324 --------------
 JavaLauncherApp/src/udt/core.cpp      | 108 +++--
 JavaLauncherApp/src/udt/core.h        |   5 +
 JavaLauncherApp/src/udt/epoll.cpp     |  60 ++-
 JavaLauncherApp/src/udt/epoll.h       |   5 +
 JavaLauncherApp/src/udt/queue.h       |   2 +-
 JavaLauncherApp/src/udt/udt.h         |   7 +-
 JavaLauncherApp/src/udt/udtCommon.cpp | 122 +++---
 JavaLauncherApp/src/udt/udtCommon.h   |  52 ++-
 13 files changed, 298 insertions(+), 1246 deletions(-)
 delete mode 100644 JavaLauncherApp/src/udt/common.cpp
 delete mode 100644 JavaLauncherApp/src/udt/common.h

diff --git a/JavaLauncherApp/src/udt/api.cpp b/JavaLauncherApp/src/udt/api.cpp
index e444218..9db8cdb 100644
--- a/JavaLauncherApp/src/udt/api.cpp
+++ b/JavaLauncherApp/src/udt/api.cpp
@@ -494,7 +494,7 @@ UDTSTATUS CUDTUnited::getStatus(const UDTSOCKET u)
    if (i->second->m_pUDT->m_bBroken)
       return BROKEN;
 
-   return i->second->m_Status;   
+   return i->second->m_Status;
 }
 
 int CUDTUnited::bind(const UDTSOCKET u, const sockaddr* name, int namelen)
@@ -1104,6 +1104,32 @@ int CUDTUnited::epoll_add_usock(const int eid, const UDTSOCKET u, const int* eve
    return ret;
 }
 
+// BARCHART
+int CUDTUnited::epoll_update_usock(const int eid, const UDTSOCKET u, const int* events)
+{
+   CUDTSocket* s = locate(u);
+   int ret = -1;
+   if (NULL != s)  {
+      ret = m_EPoll.update_usock(eid, u, events);
+   } else {
+      throw CUDTException(5, 4);
+   }
+   return ret;
+}
+
+// BARCHART
+int CUDTUnited::epoll_verify_usock(const int eid, const UDTSOCKET u, int* events)
+{
+   CUDTSocket* s = locate(u);
+   int ret = -1;
+   if (NULL != s)  {
+      ret = m_EPoll.verify_usock(eid, u, events);
+   } else {
+      throw CUDTException(5, 4);
+   }
+   return ret;
+}
+
 int CUDTUnited::epoll_add_ssock(const int eid, const SYSSOCKET s, const int* events)
 {
    return m_EPoll.add_ssock(eid, s, events);
@@ -1111,8 +1137,6 @@ int CUDTUnited::epoll_add_ssock(const int eid, const SYSSOCKET s, const int* eve
 
 int CUDTUnited::epoll_remove_usock(const int eid, const UDTSOCKET u)
 {
-   int ret = m_EPoll.remove_usock(eid, u);
-
    CUDTSocket* s = locate(u);
    if (NULL != s)
    {
@@ -1123,7 +1147,7 @@ int CUDTUnited::epoll_remove_usock(const int eid, const UDTSOCKET u)
    //   throw CUDTException(5, 4);
    //}
 
-   return ret;
+   return m_EPoll.remove_usock(eid, u);
 }
 
 int CUDTUnited::epoll_remove_ssock(const int eid, const SYSSOCKET s)
@@ -1226,7 +1250,7 @@ void CUDTUnited::checkBrokenSockets()
    {
       if (j->second->m_pUDT->m_ullLingerExpiration > 0)
       {
-         // asynchronous close: 
+         // asynchronous close:
          if ((NULL == j->second->m_pUDT->m_pSndBuffer) || (0 == j->second->m_pUDT->m_pSndBuffer->getCurrBufSize()) || (j->second->m_pUDT->m_ullLingerExpiration <= CTimer::getTime()))
          {
             j->second->m_pUDT->m_ullLingerExpiration = 0;
@@ -2012,6 +2036,45 @@ int CUDT::epoll_add_usock(const int eid, const UDTSOCKET u, const int* events)
    }
 }
 
+// BARCHART
+int CUDT::epoll_update_usock(const int eid, const UDTSOCKET u, const int* events)
+{
+   try
+   {
+      return s_UDTUnited.epoll_update_usock(eid, u, events);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+// BARCHART
+int CUDT::epoll_verify_usock(const int eid, const UDTSOCKET u, int* events)
+{
+   try
+   {
+      return s_UDTUnited.epoll_verify_usock(eid, u, events);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+
 int CUDT::epoll_add_ssock(const int eid, const SYSSOCKET s, const int* events)
 {
    try
@@ -2289,6 +2352,18 @@ int epoll_add_usock(int eid, UDTSOCKET u, const int* events)
    return CUDT::epoll_add_usock(eid, u, events);
 }
 
+// BARCHART
+int epoll_update_usock(int eid, UDTSOCKET u, const int* events)
+{
+   return CUDT::epoll_update_usock(eid, u, events);
+}
+
+// BARCHART
+int epoll_verify_usock(int eid, UDTSOCKET u, int* events)
+{
+   return CUDT::epoll_verify_usock(eid, u, events);
+}
+
 int epoll_add_ssock(int eid, SYSSOCKET s, const int* events)
 {
    return CUDT::epoll_add_ssock(eid, s, events);
diff --git a/JavaLauncherApp/src/udt/api.h b/JavaLauncherApp/src/udt/api.h
index 24f1a02..2f5f434 100644
--- a/JavaLauncherApp/src/udt/api.h
+++ b/JavaLauncherApp/src/udt/api.h
@@ -181,6 +181,11 @@ public:
    int epoll_wait(const int eid, std::set<UDTSOCKET>* readfds, std::set<UDTSOCKET>* writefds, int64_t msTimeOut, std::set<SYSSOCKET>* lrfds = NULL, std::set<SYSSOCKET>* lwfds = NULL);
    int epoll_release(const int eid);
 
+   // BARCHART
+   int epoll_update_usock(const int eid, const UDTSOCKET u, const int* events = NULL);
+   // BARCHART
+   int epoll_verify_usock(const int eid, const UDTSOCKET u, int* events);
+
       // Functionality:
       //    record the UDT exception.
       // Parameters:
diff --git a/JavaLauncherApp/src/udt/ccc.cpp b/JavaLauncherApp/src/udt/ccc.cpp
index 048b7ec..a58816f 100644
--- a/JavaLauncherApp/src/udt/ccc.cpp
+++ b/JavaLauncherApp/src/udt/ccc.cpp
@@ -35,7 +35,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 /*****************************************************************************
 written by
-   Yunhong Gu, last updated 02/21/2013
+   Yunhong Gu, last updated 02/28/2012
 *****************************************************************************/
 
 
@@ -213,7 +213,7 @@ void CUDTCC::onACK(int32_t ack)
          if (m_iRcvRate > 0)
             m_dPktSndPeriod = 1000000.0 / m_iRcvRate;
          else
-            m_dPktSndPeriod = (m_iRTT + m_iRCInterval) / m_dCWndSize;
+            m_dPktSndPeriod = m_dCWndSize / (m_iRTT + m_iRCInterval);
       }
    }
    else
diff --git a/JavaLauncherApp/src/udt/common.cpp b/JavaLauncherApp/src/udt/common.cpp
deleted file mode 100644
index 3b6ffda..0000000
--- a/JavaLauncherApp/src/udt/common.cpp
+++ /dev/null
@@ -1,765 +0,0 @@
-/*****************************************************************************
-Copyright (c) 2001 - 2010, The Board of Trustees of the University of Illinois.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-* Redistributions of source code must retain the above
-  copyright notice, this list of conditions and the
-  following disclaimer.
-
-* Redistributions in binary form must reproduce the
-  above copyright notice, this list of conditions
-  and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-* Neither the name of the University of Illinois
-  nor the names of its contributors may be used to
-  endorse or promote products derived from this
-  software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*****************************************************************************/
-
-/*****************************************************************************
-written by
-   Yunhong Gu, last updated 07/25/2010
-*****************************************************************************/
-
-
-#ifndef WIN32
-   #include <cstring>
-   #include <cerrno>
-   #include <unistd.h>
-   #ifdef OSX
-      #include <mach/mach_time.h>
-   #endif
-#else
-   #include <winsock2.h>
-   #include <ws2tcpip.h>
-   #ifdef LEGACY_WIN32
-      #include <wspiapi.h>
-   #endif
-#endif
-
-#include <cmath>
-#include "md5.h"
-#include "common.h"
-
-bool CTimer::m_bUseMicroSecond = false;
-uint64_t CTimer::s_ullCPUFrequency = CTimer::readCPUFrequency();
-#ifndef WIN32
-   pthread_mutex_t CTimer::m_EventLock = PTHREAD_MUTEX_INITIALIZER;
-   pthread_cond_t CTimer::m_EventCond = PTHREAD_COND_INITIALIZER;
-#else
-   pthread_mutex_t CTimer::m_EventLock = CreateMutex(NULL, false, NULL);
-   pthread_cond_t CTimer::m_EventCond = CreateEvent(NULL, false, false, NULL);
-#endif
-
-CTimer::CTimer():
-m_ullSchedTime(),
-m_TickCond(),
-m_TickLock()
-{
-   #ifndef WIN32
-      pthread_mutex_init(&m_TickLock, NULL);
-      pthread_cond_init(&m_TickCond, NULL);
-   #else
-      m_TickLock = CreateMutex(NULL, false, NULL);
-      m_TickCond = CreateEvent(NULL, false, false, NULL);
-   #endif
-}
-
-CTimer::~CTimer()
-{
-   #ifndef WIN32
-      pthread_mutex_destroy(&m_TickLock);
-      pthread_cond_destroy(&m_TickCond);
-   #else
-      CloseHandle(m_TickLock);
-      CloseHandle(m_TickCond);
-   #endif
-}
-
-void CTimer::rdtsc(uint64_t &x)
-{
-   if (m_bUseMicroSecond)
-   {
-      x = getTime();
-      return;
-   }
-
-   #ifdef IA32
-      uint32_t lval, hval;
-      //asm volatile ("push %eax; push %ebx; push %ecx; push %edx");
-      //asm volatile ("xor %eax, %eax; cpuid");
-      asm volatile ("rdtsc" : "=a" (lval), "=d" (hval));
-      //asm volatile ("pop %edx; pop %ecx; pop %ebx; pop %eax");
-      x = hval;
-      x = (x << 32) | lval;
-   #elif defined(IA64)
-      asm ("mov %0=ar.itc" : "=r"(x) :: "memory");
-   #elif defined(AMD64)
-      uint32_t lval, hval;
-      asm ("rdtsc" : "=a" (lval), "=d" (hval));
-      x = hval;
-      x = (x << 32) | lval;
-   #elif defined(WIN32)
-      //HANDLE hCurThread = ::GetCurrentThread(); 
-      //DWORD_PTR dwOldMask = ::SetThreadAffinityMask(hCurThread, 1); 
-      BOOL ret = QueryPerformanceCounter((LARGE_INTEGER *)&x);
-      //SetThreadAffinityMask(hCurThread, dwOldMask);
-      if (!ret)
-         x = getTime() * s_ullCPUFrequency;
-   #elif defined(OSX)
-      x = mach_absolute_time();
-   #else
-      // use system call to read time clock for other archs
-      x = getTime();
-   #endif
-}
-
-uint64_t CTimer::readCPUFrequency()
-{
-   uint64_t frequency = 1;  // 1 tick per microsecond.
-
-   #if defined(IA32) || defined(IA64) || defined(AMD64)
-      uint64_t t1, t2;
-
-      rdtsc(t1);
-      timespec ts;
-      ts.tv_sec = 0;
-      ts.tv_nsec = 100000000;
-      nanosleep(&ts, NULL);
-      rdtsc(t2);
-
-      // CPU clocks per microsecond
-      frequency = (t2 - t1) / 100000;
-   #elif defined(WIN32)
-      int64_t ccf;
-      if (QueryPerformanceFrequency((LARGE_INTEGER *)&ccf))
-         frequency = ccf / 1000000;
-   #elif defined(OSX)
-      mach_timebase_info_data_t info;
-      mach_timebase_info(&info);
-      frequency = info.denom * 1000ULL / info.numer;
-   #endif
-
-   // Fall back to microsecond if the resolution is not high enough.
-   if (frequency < 10)
-   {
-      frequency = 1;
-      m_bUseMicroSecond = true;
-   }
-   return frequency;
-}
-
-uint64_t CTimer::getCPUFrequency()
-{
-   return s_ullCPUFrequency;
-}
-
-void CTimer::sleep(uint64_t interval)
-{
-   uint64_t t;
-   rdtsc(t);
-
-   // sleep next "interval" time
-   sleepto(t + interval);
-}
-
-void CTimer::sleepto(uint64_t nexttime)
-{
-   // Use class member such that the method can be interrupted by others
-   m_ullSchedTime = nexttime;
-
-   uint64_t t;
-   rdtsc(t);
-
-   while (t < m_ullSchedTime)
-   {
-      #ifndef NO_BUSY_WAITING
-         #ifdef IA32
-            __asm__ volatile ("pause; rep; nop; nop; nop; nop; nop;");
-         #elif IA64
-            __asm__ volatile ("nop 0; nop 0; nop 0; nop 0; nop 0;");
-         #elif AMD64
-            __asm__ volatile ("nop; nop; nop; nop; nop;");
-         #endif
-      #else
-         #ifndef WIN32
-            timeval now;
-            timespec timeout;
-            gettimeofday(&now, 0);
-            if (now.tv_usec < 990000)
-            {
-               timeout.tv_sec = now.tv_sec;
-               timeout.tv_nsec = (now.tv_usec + 10000) * 1000;
-            }
-            else
-            {
-               timeout.tv_sec = now.tv_sec + 1;
-               timeout.tv_nsec = (now.tv_usec + 10000 - 1000000) * 1000;
-            }
-            pthread_mutex_lock(&m_TickLock);
-            pthread_cond_timedwait(&m_TickCond, &m_TickLock, &timeout);
-            pthread_mutex_unlock(&m_TickLock);
-         #else
-            WaitForSingleObject(m_TickCond, 1);
-         #endif
-      #endif
-
-      rdtsc(t);
-   }
-}
-
-void CTimer::interrupt()
-{
-   // schedule the sleepto time to the current CCs, so that it will stop
-   rdtsc(m_ullSchedTime);
-   tick();
-}
-
-void CTimer::tick()
-{
-   #ifndef WIN32
-      pthread_cond_signal(&m_TickCond);
-   #else
-      SetEvent(m_TickCond);
-   #endif
-}
-
-uint64_t CTimer::getTime()
-{
-   //For Cygwin and other systems without microsecond level resolution, uncomment the following three lines
-   //uint64_t x;
-   //rdtsc(x);
-   //return x / s_ullCPUFrequency;
-   //Specific fix may be necessary if rdtsc is not available either.
-
-   #ifndef WIN32
-      timeval t;
-      gettimeofday(&t, 0);
-      return t.tv_sec * 1000000ULL + t.tv_usec;
-   #else
-      LARGE_INTEGER ccf;
-      HANDLE hCurThread = ::GetCurrentThread(); 
-      DWORD_PTR dwOldMask = ::SetThreadAffinityMask(hCurThread, 1);
-      if (QueryPerformanceFrequency(&ccf))
-      {
-         LARGE_INTEGER cc;
-         if (QueryPerformanceCounter(&cc))
-         {
-            SetThreadAffinityMask(hCurThread, dwOldMask); 
-            return (cc.QuadPart * 1000000ULL / ccf.QuadPart);
-         }
-      }
-
-      SetThreadAffinityMask(hCurThread, dwOldMask); 
-      return GetTickCount() * 1000ULL;
-   #endif
-}
-
-void CTimer::triggerEvent()
-{
-   #ifndef WIN32
-      pthread_cond_signal(&m_EventCond);
-   #else
-      SetEvent(m_EventCond);
-   #endif
-}
-
-void CTimer::waitForEvent()
-{
-   #ifndef WIN32
-      timeval now;
-      timespec timeout;
-      gettimeofday(&now, 0);
-      if (now.tv_usec < 990000)
-      {
-         timeout.tv_sec = now.tv_sec;
-         timeout.tv_nsec = (now.tv_usec + 10000) * 1000;
-      }
-      else
-      {
-         timeout.tv_sec = now.tv_sec + 1;
-         timeout.tv_nsec = (now.tv_usec + 10000 - 1000000) * 1000;
-      }
-      pthread_mutex_lock(&m_EventLock);
-      pthread_cond_timedwait(&m_EventCond, &m_EventLock, &timeout);
-      pthread_mutex_unlock(&m_EventLock);
-   #else
-      WaitForSingleObject(m_EventCond, 1);
-   #endif
-}
-
-void CTimer::sleep()
-{
-   #ifndef WIN32
-      usleep(10);
-   #else
-      Sleep(1);
-   #endif
-}
-
-
-//
-// Automatically lock in constructor
-CGuard::CGuard(pthread_mutex_t& lock):
-m_Mutex(lock),
-m_iLocked()
-{
-   #ifndef WIN32
-      m_iLocked = pthread_mutex_lock(&m_Mutex);
-   #else
-      m_iLocked = WaitForSingleObject(m_Mutex, INFINITE);
-   #endif
-}
-
-// Automatically unlock in destructor
-CGuard::~CGuard()
-{
-   #ifndef WIN32
-      if (0 == m_iLocked)
-         pthread_mutex_unlock(&m_Mutex);
-   #else
-      if (WAIT_FAILED != m_iLocked)
-         ReleaseMutex(m_Mutex);
-   #endif
-}
-
-void CGuard::enterCS(pthread_mutex_t& lock)
-{
-   #ifndef WIN32
-      pthread_mutex_lock(&lock);
-   #else
-      WaitForSingleObject(lock, INFINITE);
-   #endif
-}
-
-void CGuard::leaveCS(pthread_mutex_t& lock)
-{
-   #ifndef WIN32
-      pthread_mutex_unlock(&lock);
-   #else
-      ReleaseMutex(lock);
-   #endif
-}
-
-void CGuard::createMutex(pthread_mutex_t& lock)
-{
-   #ifndef WIN32
-      pthread_mutex_init(&lock, NULL);
-   #else
-      lock = CreateMutex(NULL, false, NULL);
-   #endif
-}
-
-void CGuard::releaseMutex(pthread_mutex_t& lock)
-{
-   #ifndef WIN32
-      pthread_mutex_destroy(&lock);
-   #else
-      CloseHandle(lock);
-   #endif
-}
-
-void CGuard::createCond(pthread_cond_t& cond)
-{
-   #ifndef WIN32
-      pthread_cond_init(&cond, NULL);
-   #else
-      cond = CreateEvent(NULL, false, false, NULL);
-   #endif
-}
-
-void CGuard::releaseCond(pthread_cond_t& cond)
-{
-   #ifndef WIN32
-      pthread_cond_destroy(&cond);
-   #else
-      CloseHandle(cond);
-   #endif
-
-}
-
-//
-CUDTException::CUDTException(int major, int minor, int err):
-m_iMajor(major),
-m_iMinor(minor)
-{
-   if (-1 == err)
-      #ifndef WIN32
-         m_iErrno = errno;
-      #else
-         m_iErrno = GetLastError();
-      #endif
-   else
-      m_iErrno = err;
-}
-
-CUDTException::CUDTException(const CUDTException& e):
-m_iMajor(e.m_iMajor),
-m_iMinor(e.m_iMinor),
-m_iErrno(e.m_iErrno),
-m_strMsg()
-{
-}
-
-CUDTException::~CUDTException()
-{
-}
-
-const char* CUDTException::getErrorMessage()
-{
-   // translate "Major:Minor" code into text message.
-
-   switch (m_iMajor)
-   {
-      case 0:
-        m_strMsg = "Success";
-        break;
-
-      case 1:
-        m_strMsg = "Connection setup failure";
-
-        switch (m_iMinor)
-        {
-        case 1:
-           m_strMsg += ": connection time out";
-           break;
-
-        case 2:
-           m_strMsg += ": connection rejected";
-           break;
-
-        case 3:
-           m_strMsg += ": unable to create/configure UDP socket";
-           break;
-
-        case 4:
-           m_strMsg += ": abort for security reasons";
-           break;
-
-        default:
-           break;
-        }
-
-        break;
-
-      case 2:
-        switch (m_iMinor)
-        {
-        case 1:
-           m_strMsg = "Connection was broken";
-           break;
-
-        case 2:
-           m_strMsg = "Connection does not exist";
-           break;
-
-        default:
-           break;
-        }
-
-        break;
-
-      case 3:
-        m_strMsg = "System resource failure";
-
-        switch (m_iMinor)
-        {
-        case 1:
-           m_strMsg += ": unable to create new threads";
-           break;
-
-        case 2:
-           m_strMsg += ": unable to allocate buffers";
-           break;
-
-        default:
-           break;
-        }
-
-        break;
-
-      case 4:
-        m_strMsg = "File system failure";
-
-        switch (m_iMinor)
-        {
-        case 1:
-           m_strMsg += ": cannot seek read position";
-           break;
-
-        case 2:
-           m_strMsg += ": failure in read";
-           break;
-
-        case 3:
-           m_strMsg += ": cannot seek write position";
-           break;
-
-        case 4:
-           m_strMsg += ": failure in write";
-           break;
-
-        default:
-           break;
-        }
-
-        break;
-
-      case 5:
-        m_strMsg = "Operation not supported";
- 
-        switch (m_iMinor)
-        {
-        case 1:
-           m_strMsg += ": Cannot do this operation on a BOUND socket";
-           break;
-
-        case 2:
-           m_strMsg += ": Cannot do this operation on a CONNECTED socket";
-           break;
-
-        case 3:
-           m_strMsg += ": Bad parameters";
-           break;
-
-        case 4:
-           m_strMsg += ": Invalid socket ID";
-           break;
-
-        case 5:
-           m_strMsg += ": Cannot do this operation on an UNBOUND socket";
-           break;
-
-        case 6:
-           m_strMsg += ": Socket is not in listening state";
-           break;
-
-        case 7:
-           m_strMsg += ": Listen/accept is not supported in rendezous connection setup";
-           break;
-
-        case 8:
-           m_strMsg += ": Cannot call connect on UNBOUND socket in rendezvous connection setup";
-           break;
-
-        case 9:
-           m_strMsg += ": This operation is not supported in SOCK_STREAM mode";
-           break;
-
-        case 10:
-           m_strMsg += ": This operation is not supported in SOCK_DGRAM mode";
-           break;
-
-        case 11:
-           m_strMsg += ": Another socket is already listening on the same port";
-           break;
-
-        case 12:
-           m_strMsg += ": Message is too large to send (it must be less than the UDT send buffer size)";
-           break;
-
-        case 13:
-           m_strMsg += ": Invalid epoll ID";
-           break;
-
-        default:
-           break;
-        }
-
-        break;
-
-     case 6:
-        m_strMsg = "Non-blocking call failure";
-
-        switch (m_iMinor)
-        {
-        case 1:
-           m_strMsg += ": no buffer available for sending";
-           break;
-
-        case 2:
-           m_strMsg += ": no data available for reading";
-           break;
-
-        default:
-           break;
-        }
-
-        break;
-
-     case 7:
-        m_strMsg = "The peer side has signalled an error";
-
-        break;
-
-      default:
-        m_strMsg = "Unknown error";
-   }
-
-   // Adding "errno" information
-   if ((0 != m_iMajor) && (0 < m_iErrno))
-   {
-      m_strMsg += ": ";
-      #ifndef WIN32
-         char errmsg[1024];
-         if (strerror_r(m_iErrno, errmsg, 1024) == 0)
-            m_strMsg += errmsg;
-      #else
-         LPVOID lpMsgBuf;
-         FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, m_iErrno, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpMsgBuf, 0, NULL);
-         m_strMsg += (char*)lpMsgBuf;
-         LocalFree(lpMsgBuf);
-      #endif
-   }
-
-   // period
-   #ifndef WIN32
-      m_strMsg += ".";
-   #endif
-
-   return m_strMsg.c_str();
-}
-
-int CUDTException::getErrorCode() const
-{
-   return m_iMajor * 1000 + m_iMinor;
-}
-
-void CUDTException::clear()
-{
-   m_iMajor = 0;
-   m_iMinor = 0;
-   m_iErrno = 0;
-}
-
-const int CUDTException::SUCCESS = 0;
-const int CUDTException::ECONNSETUP = 1000;
-const int CUDTException::ENOSERVER = 1001;
-const int CUDTException::ECONNREJ = 1002;
-const int CUDTException::ESOCKFAIL = 1003;
-const int CUDTException::ESECFAIL = 1004;
-const int CUDTException::ECONNFAIL = 2000;
-const int CUDTException::ECONNLOST = 2001;
-const int CUDTException::ENOCONN = 2002;
-const int CUDTException::ERESOURCE = 3000;
-const int CUDTException::ETHREAD = 3001;
-const int CUDTException::ENOBUF = 3002;
-const int CUDTException::EFILE = 4000;
-const int CUDTException::EINVRDOFF = 4001;
-const int CUDTException::ERDPERM = 4002;
-const int CUDTException::EINVWROFF = 4003;
-const int CUDTException::EWRPERM = 4004;
-const int CUDTException::EINVOP = 5000;
-const int CUDTException::EBOUNDSOCK = 5001;
-const int CUDTException::ECONNSOCK = 5002;
-const int CUDTException::EINVPARAM = 5003;
-const int CUDTException::EINVSOCK = 5004;
-const int CUDTException::EUNBOUNDSOCK = 5005;
-const int CUDTException::ENOLISTEN = 5006;
-const int CUDTException::ERDVNOSERV = 5007;
-const int CUDTException::ERDVUNBOUND = 5008;
-const int CUDTException::ESTREAMILL = 5009;
-const int CUDTException::EDGRAMILL = 5010;
-const int CUDTException::EDUPLISTEN = 5011;
-const int CUDTException::ELARGEMSG = 5012;
-const int CUDTException::EINVPOLLID = 5013;
-const int CUDTException::EASYNCFAIL = 6000;
-const int CUDTException::EASYNCSND = 6001;
-const int CUDTException::EASYNCRCV = 6002;
-const int CUDTException::ETIMEOUT = 6003;
-const int CUDTException::EPEERERR = 7000;
-const int CUDTException::EUNKNOWN = -1;
-
-
-//
-bool CIPAddress::ipcmp(const sockaddr* addr1, const sockaddr* addr2, int ver)
-{
-   if (AF_INET == ver)
-   {
-      sockaddr_in* a1 = (sockaddr_in*)addr1;
-      sockaddr_in* a2 = (sockaddr_in*)addr2;
-
-      if ((a1->sin_port == a2->sin_port) && (a1->sin_addr.s_addr == a2->sin_addr.s_addr))
-         return true;
-   }
-   else
-   {
-      sockaddr_in6* a1 = (sockaddr_in6*)addr1;
-      sockaddr_in6* a2 = (sockaddr_in6*)addr2;
-
-      if (a1->sin6_port == a2->sin6_port)
-      {
-         for (int i = 0; i < 16; ++ i)
-            if (*((char*)&(a1->sin6_addr) + i) != *((char*)&(a2->sin6_addr) + i))
-               return false;
-
-         return true;
-      }
-   }
-
-   return false;
-}
-
-void CIPAddress::ntop(const sockaddr* addr, uint32_t ip[4], int ver)
-{
-   if (AF_INET == ver)
-   {
-      sockaddr_in* a = (sockaddr_in*)addr;
-      ip[0] = a->sin_addr.s_addr;
-   }
-   else
-   {
-      sockaddr_in6* a = (sockaddr_in6*)addr;
-      ip[3] = (a->sin6_addr.s6_addr[15] << 24) + (a->sin6_addr.s6_addr[14] << 16) + (a->sin6_addr.s6_addr[13] << 8) + a->sin6_addr.s6_addr[12];
-      ip[2] = (a->sin6_addr.s6_addr[11] << 24) + (a->sin6_addr.s6_addr[10] << 16) + (a->sin6_addr.s6_addr[9] << 8) + a->sin6_addr.s6_addr[8];
-      ip[1] = (a->sin6_addr.s6_addr[7] << 24) + (a->sin6_addr.s6_addr[6] << 16) + (a->sin6_addr.s6_addr[5] << 8) + a->sin6_addr.s6_addr[4];
-      ip[0] = (a->sin6_addr.s6_addr[3] << 24) + (a->sin6_addr.s6_addr[2] << 16) + (a->sin6_addr.s6_addr[1] << 8) + a->sin6_addr.s6_addr[0];
-   }
-}
-
-void CIPAddress::pton(sockaddr* addr, const uint32_t ip[4], int ver)
-{
-   if (AF_INET == ver)
-   {
-      sockaddr_in* a = (sockaddr_in*)addr;
-      a->sin_addr.s_addr = ip[0];
-   }
-   else
-   {
-      sockaddr_in6* a = (sockaddr_in6*)addr;
-      for (int i = 0; i < 4; ++ i)
-      {
-         a->sin6_addr.s6_addr[i * 4] = ip[i] & 0xFF;
-         a->sin6_addr.s6_addr[i * 4 + 1] = (unsigned char)((ip[i] & 0xFF00) >> 8);
-         a->sin6_addr.s6_addr[i * 4 + 2] = (unsigned char)((ip[i] & 0xFF0000) >> 16);
-         a->sin6_addr.s6_addr[i * 4 + 3] = (unsigned char)((ip[i] & 0xFF000000) >> 24);
-      }
-   }
-}
-
-//
-void CMD5::compute(const char* input, unsigned char result[16])
-{
-   md5_state_t state;
-
-   md5_init(&state);
-   md5_append(&state, (const md5_byte_t *)input, strlen(input));
-   md5_finish(&state, result);
-}
diff --git a/JavaLauncherApp/src/udt/common.h b/JavaLauncherApp/src/udt/common.h
deleted file mode 100644
index 3ecf846..0000000
--- a/JavaLauncherApp/src/udt/common.h
+++ /dev/null
@@ -1,324 +0,0 @@
-/*****************************************************************************
-Copyright (c) 2001 - 2009, The Board of Trustees of the University of Illinois.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-* Redistributions of source code must retain the above
-  copyright notice, this list of conditions and the
-  following disclaimer.
-
-* Redistributions in binary form must reproduce the
-  above copyright notice, this list of conditions
-  and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-* Neither the name of the University of Illinois
-  nor the names of its contributors may be used to
-  endorse or promote products derived from this
-  software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*****************************************************************************/
-
-/*****************************************************************************
-written by
-   Yunhong Gu, last updated 08/01/2009
-*****************************************************************************/
-
-#ifndef __UDT_COMMON_H__
-#define __UDT_COMMON_H__
-
-
-#ifndef WIN32
-   #include <sys/time.h>
-   #include <sys/uio.h>
-   #include <pthread.h>
-#else
-   #ifdef __MINGW__
-      #include <stdint.h>
-      #include <ws2tcpip.h>
-   #endif
-   #include <windows.h>
-#endif
-#include <cstdlib>
-#include "udt.h"
-
-
-#ifdef WIN32
-   // Windows compability
-   typedef HANDLE pthread_t;
-   typedef HANDLE pthread_mutex_t;
-   typedef HANDLE pthread_cond_t;
-   typedef DWORD pthread_key_t;
-#endif
-
-
-////////////////////////////////////////////////////////////////////////////////
-
-class CTimer
-{
-public:
-   CTimer();
-   ~CTimer();
-
-public:
-
-      // Functionality:
-      //    Sleep for "interval" CCs.
-      // Parameters:
-      //    0) [in] interval: CCs to sleep.
-      // Returned value:
-      //    None.
-
-   void sleep(uint64_t interval);
-
-      // Functionality:
-      //    Seelp until CC "nexttime".
-      // Parameters:
-      //    0) [in] nexttime: next time the caller is waken up.
-      // Returned value:
-      //    None.
-
-   void sleepto(uint64_t nexttime);
-
-      // Functionality:
-      //    Stop the sleep() or sleepto() methods.
-      // Parameters:
-      //    None.
-      // Returned value:
-      //    None.
-
-   void interrupt();
-
-      // Functionality:
-      //    trigger the clock for a tick, for better granuality in no_busy_waiting timer.
-      // Parameters:
-      //    None.
-      // Returned value:
-      //    None.
-
-   void tick();
-
-public:
-
-      // Functionality:
-      //    Read the CPU clock cycle into x.
-      // Parameters:
-      //    0) [out] x: to record cpu clock cycles.
-      // Returned value:
-      //    None.
-
-   static void rdtsc(uint64_t &x);
-
-      // Functionality:
-      //    return the CPU frequency.
-      // Parameters:
-      //    None.
-      // Returned value:
-      //    CPU frequency.
-
-   static uint64_t getCPUFrequency();
-
-      // Functionality:
-      //    check the current time, 64bit, in microseconds.
-      // Parameters:
-      //    None.
-      // Returned value:
-      //    current time in microseconds.
-
-   static uint64_t getTime();
-
-      // Functionality:
-      //    trigger an event such as new connection, close, new data, etc. for "select" call.
-      // Parameters:
-      //    None.
-      // Returned value:
-      //    None.
-
-   static void triggerEvent();
-
-      // Functionality:
-      //    wait for an event to br triggered by "triggerEvent".
-      // Parameters:
-      //    None.
-      // Returned value:
-      //    None.
-
-   static void waitForEvent();
-
-      // Functionality:
-      //    sleep for a short interval. exact sleep time does not matter
-      // Parameters:
-      //    None.
-      // Returned value:
-      //    None.
-
-   static void sleep();
-
-private:
-   uint64_t getTimeInMicroSec();
-
-private:
-   uint64_t m_ullSchedTime;             // next schedulled time
-
-   pthread_cond_t m_TickCond;
-   pthread_mutex_t m_TickLock;
-
-   static pthread_cond_t m_EventCond;
-   static pthread_mutex_t m_EventLock;
-
-private:
-   static uint64_t s_ullCPUFrequency;	// CPU frequency : clock cycles per microsecond
-   static uint64_t readCPUFrequency();
-   static bool m_bUseMicroSecond;       // No higher resolution timer available, use gettimeofday().
-};
-
-////////////////////////////////////////////////////////////////////////////////
-
-class CGuard
-{
-public:
-   CGuard(pthread_mutex_t& lock);
-   ~CGuard();
-
-public:
-   static void enterCS(pthread_mutex_t& lock);
-   static void leaveCS(pthread_mutex_t& lock);
-
-   static void createMutex(pthread_mutex_t& lock);
-   static void releaseMutex(pthread_mutex_t& lock);
-
-   static void createCond(pthread_cond_t& cond);
-   static void releaseCond(pthread_cond_t& cond);
-
-private:
-   pthread_mutex_t& m_Mutex;            // Alias name of the mutex to be protected
-   int m_iLocked;                       // Locking status
-
-   CGuard& operator=(const CGuard&);
-};
-
-
-
-////////////////////////////////////////////////////////////////////////////////
-
-// UDT Sequence Number 0 - (2^31 - 1)
-
-// seqcmp: compare two seq#, considering the wraping
-// seqlen: length from the 1st to the 2nd seq#, including both
-// seqoff: offset from the 2nd to the 1st seq#
-// incseq: increase the seq# by 1
-// decseq: decrease the seq# by 1
-// incseq: increase the seq# by a given offset
-
-class CSeqNo
-{
-public:
-   inline static int seqcmp(int32_t seq1, int32_t seq2)
-   {return (abs(seq1 - seq2) < m_iSeqNoTH) ? (seq1 - seq2) : (seq2 - seq1);}
-
-   inline static int seqlen(int32_t seq1, int32_t seq2)
-   {return (seq1 <= seq2) ? (seq2 - seq1 + 1) : (seq2 - seq1 + m_iMaxSeqNo + 2);}
-
-   inline static int seqoff(int32_t seq1, int32_t seq2)
-   {
-      if (abs(seq1 - seq2) < m_iSeqNoTH)
-         return seq2 - seq1;
-
-      if (seq1 < seq2)
-         return seq2 - seq1 - m_iMaxSeqNo - 1;
-
-      return seq2 - seq1 + m_iMaxSeqNo + 1;
-   }
-
-   inline static int32_t incseq(int32_t seq)
-   {return (seq == m_iMaxSeqNo) ? 0 : seq + 1;}
-
-   inline static int32_t decseq(int32_t seq)
-   {return (seq == 0) ? m_iMaxSeqNo : seq - 1;}
-
-   inline static int32_t incseq(int32_t seq, int32_t inc)
-   {return (m_iMaxSeqNo - seq >= inc) ? seq + inc : seq - m_iMaxSeqNo + inc - 1;}
-
-public:
-   static const int32_t m_iSeqNoTH;             // threshold for comparing seq. no.
-   static const int32_t m_iMaxSeqNo;            // maximum sequence number used in UDT
-};
-
-////////////////////////////////////////////////////////////////////////////////
-
-// UDT ACK Sub-sequence Number: 0 - (2^31 - 1)
-
-class CAckNo
-{
-public:
-   inline static int32_t incack(int32_t ackno)
-   {return (ackno == m_iMaxAckSeqNo) ? 0 : ackno + 1;}
-
-public:
-   static const int32_t m_iMaxAckSeqNo;         // maximum ACK sub-sequence number used in UDT
-};
-
-////////////////////////////////////////////////////////////////////////////////
-
-// UDT Message Number: 0 - (2^29 - 1)
-
-class CMsgNo
-{
-public:
-   inline static int msgcmp(int32_t msgno1, int32_t msgno2)
-   {return (abs(msgno1 - msgno2) < m_iMsgNoTH) ? (msgno1 - msgno2) : (msgno2 - msgno1);}
-
-   inline static int msglen(int32_t msgno1, int32_t msgno2)
-   {return (msgno1 <= msgno2) ? (msgno2 - msgno1 + 1) : (msgno2 - msgno1 + m_iMaxMsgNo + 2);}
-
-   inline static int msgoff(int32_t msgno1, int32_t msgno2)
-   {
-      if (abs(msgno1 - msgno2) < m_iMsgNoTH)
-         return msgno2 - msgno1;
-
-      if (msgno1 < msgno2)
-         return msgno2 - msgno1 - m_iMaxMsgNo - 1;
-
-      return msgno2 - msgno1 + m_iMaxMsgNo + 1;
-   }
-
-   inline static int32_t incmsg(int32_t msgno)
-   {return (msgno == m_iMaxMsgNo) ? 0 : msgno + 1;}
-
-public:
-   static const int32_t m_iMsgNoTH;             // threshold for comparing msg. no.
-   static const int32_t m_iMaxMsgNo;            // maximum message number used in UDT
-};
-
-////////////////////////////////////////////////////////////////////////////////
-
-struct CIPAddress
-{
-   static bool ipcmp(const sockaddr* addr1, const sockaddr* addr2, int ver = AF_INET);
-   static void ntop(const sockaddr* addr, uint32_t ip[4], int ver = AF_INET);
-   static void pton(sockaddr* addr, const uint32_t ip[4], int ver = AF_INET);
-};
-
-////////////////////////////////////////////////////////////////////////////////
-
-struct CMD5
-{
-   static void compute(const char* input, unsigned char result[16]);
-};
-
-
-#endif
diff --git a/JavaLauncherApp/src/udt/core.cpp b/JavaLauncherApp/src/udt/core.cpp
index 17fc960..a5b490e 100644
--- a/JavaLauncherApp/src/udt/core.cpp
+++ b/JavaLauncherApp/src/udt/core.cpp
@@ -328,13 +328,13 @@ void CUDT::setOpt(UDTOpt optName, const void* optval, int)
       m_bRendezvous = *(bool *)optval;
       break;
 
-   case UDT_SNDTIMEO: 
-      m_iSndTimeOut = *(int*)optval; 
-      break; 
-    
-   case UDT_RCVTIMEO: 
-      m_iRcvTimeOut = *(int*)optval; 
-      break; 
+   case UDT_SNDTIMEO:
+      m_iSndTimeOut = *(int*)optval;
+      break;
+
+   case UDT_RCVTIMEO:
+      m_iRcvTimeOut = *(int*)optval;
+      break;
 
    case UDT_REUSEADDR:
       if (m_bOpened)
@@ -345,7 +345,7 @@ void CUDT::setOpt(UDTOpt optName, const void* optval, int)
    case UDT_MAXBW:
       m_llMaxBW = *(int64_t*)optval;
       break;
-    
+
    default:
       throw CUDTException(5, 0, 0);
    }
@@ -418,15 +418,15 @@ void CUDT::getOpt(UDTOpt optName, void* optval, int& optlen)
       optlen = sizeof(bool);
       break;
 
-   case UDT_SNDTIMEO: 
-      *(int*)optval = m_iSndTimeOut; 
-      optlen = sizeof(int); 
-      break; 
-    
-   case UDT_RCVTIMEO: 
-      *(int*)optval = m_iRcvTimeOut; 
-      optlen = sizeof(int); 
-      break; 
+   case UDT_SNDTIMEO:
+      *(int*)optval = m_iSndTimeOut;
+      optlen = sizeof(int);
+      break;
+
+   case UDT_RCVTIMEO:
+      *(int*)optval = m_iRcvTimeOut;
+      optlen = sizeof(int);
+      break;
 
    case UDT_REUSEADDR:
       *(bool *)optval = m_bReuseAddr;
@@ -522,7 +522,7 @@ void CUDT::open()
 
    // set up the timers
    m_ullSYNInt = m_iSYNInterval * m_ullCPUFrequency;
-  
+
    // set minimum NAK and EXP timeout to 100ms
    m_ullMinNakInt = 300000 * m_ullCPUFrequency;
    m_ullMinExpInt = 300000 * m_ullCPUFrequency;
@@ -580,8 +580,6 @@ void CUDT::connect(const sockaddr* serv_addr)
    if (m_bConnecting || m_bConnected)
       throw CUDTException(5, 2, 0);
 
-   m_bConnecting = true;
-
    // record peer/server address
    delete m_pPeerAddr;
    m_pPeerAddr = (AF_INET == m_iIPversion) ? (sockaddr*)new sockaddr_in : (sockaddr*)new sockaddr_in6;
@@ -628,6 +626,8 @@ void CUDT::connect(const sockaddr* serv_addr)
    m_pSndQueue->sendto(serv_addr, request);
    m_llLastReqTime = CTimer::getTime();
 
+   m_bConnecting = true;
+
    // asynchronous connect, return immediately
    if (!m_bSynRecving)
    {
@@ -801,12 +801,12 @@ POST_CONNECT:
    m_pRNode->m_bOnList = true;
    m_pRcvQueue->setNewEntry(this);
 
-   // acknowledge the management module.
-   s_UDTUnited.connect_complete(m_SocketID);
-
    // acknowledde any waiting epolls to write
    s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, true);
 
+   // acknowledge the management module.
+   s_UDTUnited.connect_complete(m_SocketID);
+
    return 0;
 }
 
@@ -814,7 +814,7 @@ void CUDT::connect(const sockaddr* peer, CHandShake* hs)
 {
    CGuard cg(m_ConnectionLock);
 
-   // Uses the smaller MSS between the peers        
+   // Uses the smaller MSS between the peers
    if (hs->m_iMSS > m_iMSS)
       hs->m_iMSS = m_iMSS;
    else
@@ -849,7 +849,7 @@ void CUDT::connect(const sockaddr* peer, CHandShake* hs)
    // get local IP address and send the peer its IP address (because UDP cannot get local IP address)
    memcpy(m_piSelfIP, hs->m_piPeerIP, 16);
    CIPAddress::ntop(peer, hs->m_piPeerIP, m_iIPversion);
-  
+
    m_iPktSize = m_iMSS - 28;
    m_iPayloadSize = m_iPktSize - CPacket::m_iPktHdrSize;
 
@@ -959,7 +959,7 @@ void CUDT::close()
    s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, false);
    s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_ERR, true);
 
-   // then remove itself from all epoll monitoring
+   // remove itself from all epoll monitoring
    try
    {
       for (set<int>::iterator i = m_sPollID.begin(); i != m_sPollID.end(); ++ i)
@@ -1049,16 +1049,16 @@ int CUDT::send(const char* data, int len)
          // wait here during a blocking sending
          #ifndef WIN32
             pthread_mutex_lock(&m_SendBlockLock);
-            if (m_iSndTimeOut < 0) 
-            { 
+            if (m_iSndTimeOut < 0)
+            {
                while (!m_bBroken && m_bConnected && !m_bClosing && (m_iSndBufSize <= m_pSndBuffer->getCurrBufSize()) && m_bPeerHealth)
                   pthread_cond_wait(&m_SendBlockCond, &m_SendBlockLock);
             }
             else
             {
                uint64_t exptime = CTimer::getTime() + m_iSndTimeOut * 1000ULL;
-               timespec locktime; 
-    
+               timespec locktime;
+
                locktime.tv_sec = exptime / 1000000;
                locktime.tv_nsec = (exptime % 1000000) * 1000;
 
@@ -1072,12 +1072,12 @@ int CUDT::send(const char* data, int len)
                while (!m_bBroken && m_bConnected && !m_bClosing && (m_iSndBufSize <= m_pSndBuffer->getCurrBufSize()) && m_bPeerHealth)
                   WaitForSingleObject(m_SendBlockCond, INFINITE);
             }
-            else 
+            else
             {
                uint64_t exptime = CTimer::getTime() + m_iSndTimeOut * 1000ULL;
 
                while (!m_bBroken && m_bConnected && !m_bClosing && (m_iSndBufSize <= m_pSndBuffer->getCurrBufSize()) && m_bPeerHealth && (CTimer::getTime() < exptime))
-                  WaitForSingleObject(m_SendBlockCond, DWORD((exptime - CTimer::getTime()) / 1000)); 
+                  WaitForSingleObject(m_SendBlockCond, DWORD((exptime - CTimer::getTime()) / 1000));
             }
          #endif
 
@@ -1097,7 +1097,7 @@ int CUDT::send(const char* data, int len)
    if (m_iSndBufSize <= m_pSndBuffer->getCurrBufSize())
    {
       if (m_iSndTimeOut >= 0)
-         throw CUDTException(6, 3, 0); 
+         throw CUDTException(6, 3, 0);
 
       return 0;
    }
@@ -1149,22 +1149,22 @@ int CUDT::recv(char* data, int len)
       {
          #ifndef WIN32
             pthread_mutex_lock(&m_RecvDataLock);
-            if (m_iRcvTimeOut < 0) 
-            { 
+            if (m_iRcvTimeOut < 0)
+            {
                while (!m_bBroken && m_bConnected && !m_bClosing && (0 == m_pRcvBuffer->getRcvDataSize()))
                   pthread_cond_wait(&m_RecvDataCond, &m_RecvDataLock);
             }
             else
             {
-               uint64_t exptime = CTimer::getTime() + m_iRcvTimeOut * 1000ULL; 
-               timespec locktime; 
-    
+               uint64_t exptime = CTimer::getTime() + m_iRcvTimeOut * 1000ULL;
+               timespec locktime;
+
                locktime.tv_sec = exptime / 1000000;
                locktime.tv_nsec = (exptime % 1000000) * 1000;
 
                while (!m_bBroken && m_bConnected && !m_bClosing && (0 == m_pRcvBuffer->getRcvDataSize()))
                {
-                  pthread_cond_timedwait(&m_RecvDataCond, &m_RecvDataLock, &locktime); 
+                  pthread_cond_timedwait(&m_RecvDataCond, &m_RecvDataLock, &locktime);
                   if (CTimer::getTime() >= exptime)
                      break;
                }
@@ -1312,7 +1312,7 @@ int CUDT::sendmsg(const char* data, int len, int msttl, bool inorder)
       s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, false);
    }
 
-   return len;   
+   return len;
 }
 
 int CUDT::recvmsg(char* data, int len)
@@ -1378,7 +1378,7 @@ int CUDT::recvmsg(char* data, int len)
             if (pthread_cond_timedwait(&m_RecvDataCond, &m_RecvDataLock, &locktime) == ETIMEDOUT)
                timeout = true;
 
-            res = m_pRcvBuffer->readMsg(data, len);           
+            res = m_pRcvBuffer->readMsg(data, len);
          }
          pthread_mutex_unlock(&m_RecvDataLock);
       #else
@@ -1918,7 +1918,7 @@ void CUDT::sendCtrl(int pkttype, void* lparam, void* rparam, int size)
       ctrlpkt.pack(pkttype);
       ctrlpkt.m_iID = m_PeerID;
       m_pSndQueue->sendto(m_pPeerAddr, ctrlpkt);
- 
+
       break;
 
    case 0: //000 - Handshake
@@ -2438,10 +2438,10 @@ int CUDT::processData(CUnit* unit)
       m_iRcvLossTotal += loss;
    }
 
-   // This is not a regular fixed size packet...   
-   //an irregular sized packet usually indicates the end of a message, so send an ACK immediately   
-   if (packet.getLength() != m_iPayloadSize)   
-      CTimer::rdtsc(m_ullNextACKTime); 
+   // This is not a regular fixed size packet...
+   //an irregular sized packet usually indicates the end of a message, so send an ACK immediately
+   if (packet.getLength() != m_iPayloadSize)
+      CTimer::rdtsc(m_ullNextACKTime);
 
    // Update the current largest sequence number that has been received.
    // Or it is a retransmitted packet, remove it from receiver loss list.
@@ -2468,7 +2468,7 @@ int CUDT::listen(sockaddr* addr, CPacket& packet)
    char clienthost[NI_MAXHOST];
    char clientport[NI_MAXSERV];
    getnameinfo(addr, (AF_INET == m_iVersion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6), clienthost, sizeof(clienthost), clientport, sizeof(clientport), NI_NUMERICHOST|NI_NUMERICSERV);
-   int64_t timestamp = (CTimer::getTime() - m_StartTime) / 60000000;  // secret changes every one minute
+   int64_t timestamp = (CTimer::getTime() - m_StartTime) / 60000000; // secret changes every one minute
    stringstream cookiestr;
    cookiestr << clienthost << ":" << clientport << ":" << timestamp;
    unsigned char cookie[16];
@@ -2527,7 +2527,7 @@ int CUDT::listen(sockaddr* addr, CPacket& packet)
          }
          else
          {
-            // a new connection has been created, enable epoll for write 
+            // a new connection has been created, enable epoll for write
             s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_OUT, true);
          }
       }
@@ -2596,7 +2596,7 @@ void CUDT::checkTimers()
       if ((m_iEXPCount > 16) && (currtime - m_ullLastRspTime > 5000000 * m_ullCPUFrequency))
       {
          //
-         // Connection is broken. 
+         // Connection is broken.
          // UDT does not signal any information about this instead of to stop quietly.
          // Application will detect this when it calls any UDT methods next time.
          //
@@ -2669,13 +2669,11 @@ void CUDT::addEPoll(const int eid)
 
 void CUDT::removeEPoll(const int eid)
 {
-   // clear IO events notifications;
-   // since this happens after the epoll ID has been removed, they cannot be set again
-   set<int> remove;
-   remove.insert(eid);
-   s_UDTUnited.m_EPoll.update_events(m_SocketID, remove, UDT_EPOLL_IN | UDT_EPOLL_OUT, false);
-
    CGuard::enterCS(s_UDTUnited.m_EPoll.m_EPollLock);
    m_sPollID.erase(eid);
    CGuard::leaveCS(s_UDTUnited.m_EPoll.m_EPollLock);
+
+   // clear IO events notifications;
+   // since this happens after the epoll ID has been removed, they cannot be set again
+   s_UDTUnited.m_EPoll.update_events(m_SocketID, m_sPollID, UDT_EPOLL_IN | UDT_EPOLL_OUT, false);
 }
diff --git a/JavaLauncherApp/src/udt/core.h b/JavaLauncherApp/src/udt/core.h
index 47caa79..fe35404 100644
--- a/JavaLauncherApp/src/udt/core.h
+++ b/JavaLauncherApp/src/udt/core.h
@@ -108,6 +108,11 @@ public: //API
    static int perfmon(UDTSOCKET u, CPerfMon* perf, bool clear = true);
    static UDTSTATUS getsockstate(UDTSOCKET u);
 
+   // BARCHART
+   static int epoll_update_usock(const int eid, const UDTSOCKET u, const int* events = NULL);
+   // BARCHART
+   static int epoll_verify_usock(const int eid, const UDTSOCKET u, int* events);
+
 public: // internal API
    static CUDT* getUDTHandle(UDTSOCKET u);
 
diff --git a/JavaLauncherApp/src/udt/epoll.cpp b/JavaLauncherApp/src/udt/epoll.cpp
index 2805ed3..806a791 100644
--- a/JavaLauncherApp/src/udt/epoll.cpp
+++ b/JavaLauncherApp/src/udt/epoll.cpp
@@ -47,7 +47,7 @@ written by
 #include <cstring>
 #include <iterator>
 
-#include "common.h"
+#include "udtCommon.h"
 #include "epoll.h"
 #include "udt.h"
 
@@ -110,6 +110,56 @@ int CEPoll::add_usock(const int eid, const UDTSOCKET& u, const int* events)
    return 0;
 }
 
+// BARCHART
+int CEPoll::update_usock(const int eid, const UDTSOCKET& u, const int* events)
+{
+   CGuard pg(m_EPollLock);
+
+   map<int, CEPollDesc>::iterator p = m_mPolls.find(eid);
+   if (p == m_mPolls.end()){
+        throw CUDTException(5, 13);
+   }
+
+   if(events){
+    if (*events & UDT_EPOLL_IN){
+        p->second.m_sUDTSocksIn.insert(u);
+    }else{
+        p->second.m_sUDTSocksIn.erase(u);
+    }
+    if (*events & UDT_EPOLL_OUT){
+        p->second.m_sUDTSocksOut.insert(u);
+    } else{
+        p->second.m_sUDTSocksOut.erase(u);
+    }
+   }
+
+   return 0;
+}
+
+// BARCHART
+int CEPoll::verify_usock(const int eid, const UDTSOCKET& u, int* events)
+{
+
+   CGuard pg(m_EPollLock);
+
+   map<int, CEPollDesc>::iterator p = m_mPolls.find(eid);
+   if (p == m_mPolls.end()){
+        throw CUDTException(5, 13);
+   }
+
+   if(events){
+    if(p->second.m_sUDTSocksIn.find(u) != p->second.m_sUDTSocksIn.end()){
+        *events |= UDT_EPOLL_IN;
+    }
+    if(p->second.m_sUDTSocksOut.find(u) != p->second.m_sUDTSocksOut.end()){
+        *events |= UDT_EPOLL_OUT;
+    }
+   }
+
+   return 0;
+
+}
+
 int CEPoll::add_ssock(const int eid, const SYSSOCKET& s, const int* events)
 {
    CGuard pg(m_EPollLock);
@@ -120,7 +170,6 @@ int CEPoll::add_ssock(const int eid, const SYSSOCKET& s, const int* events)
 
 #ifdef LINUX
    epoll_event ev;
-   memset(&ev, 0, sizeof(epoll_event));
 
    if (NULL == events)
       ev.events = EPOLLIN | EPOLLOUT | EPOLLERR;
@@ -155,7 +204,10 @@ int CEPoll::remove_usock(const int eid, const UDTSOCKET& u)
 
    p->second.m_sUDTSocksIn.erase(u);
    p->second.m_sUDTSocksOut.erase(u);
-   p->second.m_sUDTSocksEx.erase(u);
+
+   // when the socket is removed from a monitoring, it is not available anymore for any IO notification
+   p->second.m_sUDTReads.erase(u);
+   p->second.m_sUDTWrites.erase(u);
 
    return 0;
 }
@@ -230,7 +282,7 @@ int CEPoll::wait(const int eid, set<UDTSOCKET>* readfds, set<UDTSOCKET>* writefd
 
       // BARCHART: Remove errors when reported.
       if(total > 0 && !p->second.m_sUDTExcepts.empty()){
-    	  p->second.m_sUDTExcepts.clear();
+        p->second.m_sUDTExcepts.clear();
       }
 
       if (lrfds || lwfds)
diff --git a/JavaLauncherApp/src/udt/epoll.h b/JavaLauncherApp/src/udt/epoll.h
index a19f8ab..2dc349d 100644
--- a/JavaLauncherApp/src/udt/epoll.h
+++ b/JavaLauncherApp/src/udt/epoll.h
@@ -93,6 +93,11 @@ public: // for CUDTUnited API
 
    int add_usock(const int eid, const UDTSOCKET& u, const int* events = NULL);
 
+   // BARCHART
+   int update_usock(const int eid, const UDTSOCKET& u, const int* events = NULL);
+   // BARCHART
+   int verify_usock(const int eid, const UDTSOCKET& u, int* events);
+
       // Functionality:
       //    add a system socket to an EPoll.
       // Parameters:
diff --git a/JavaLauncherApp/src/udt/queue.h b/JavaLauncherApp/src/udt/queue.h
index 9feff18..cb1b8d2 100644
--- a/JavaLauncherApp/src/udt/queue.h
+++ b/JavaLauncherApp/src/udt/queue.h
@@ -43,12 +43,12 @@ written by
 #define __UDT_QUEUE_H__
 
 #include "channel.h"
-#include "common.h"
 #include "packet.h"
 #include <list>
 #include <map>
 #include <queue>
 #include <vector>
+#include "udtCommon.h"
 
 class CUDT;
 
diff --git a/JavaLauncherApp/src/udt/udt.h b/JavaLauncherApp/src/udt/udt.h
index 6436363..24645e1 100644
--- a/JavaLauncherApp/src/udt/udt.h
+++ b/JavaLauncherApp/src/udt/udt.h
@@ -331,11 +331,16 @@ UDT_API int64_t recvfile(UDTSOCKET u, std::fstream& ofs, int64_t& offset, int64_
 UDT_API int64_t sendfile2(UDTSOCKET u, const char* path, int64_t* offset, int64_t size, int block = 364000);
 UDT_API int64_t recvfile2(UDTSOCKET u, const char* path, int64_t* offset, int64_t size, int block = 7280000);
 
-// select and selectEX are DEPRECATED; please use epoll. 
+// select and selectEX are DEPRECATED; please use epoll.
 UDT_API int select(int nfds, UDSET* readfds, UDSET* writefds, UDSET* exceptfds, const struct timeval* timeout);
 UDT_API int selectEx(const std::vector<UDTSOCKET>& fds, std::vector<UDTSOCKET>* readfds,
                      std::vector<UDTSOCKET>* writefds, std::vector<UDTSOCKET>* exceptfds, int64_t msTimeOut);
 
+// BARCHART
+UDT_API int epoll_update_usock(int eid, UDTSOCKET u, const int* events = NULL);
+// BARCHART
+UDT_API int epoll_verify_usock(int eid, UDTSOCKET u, int* events);
+
 UDT_API int epoll_create();
 UDT_API int epoll_add_usock(int eid, UDTSOCKET u, const int* events = NULL);
 UDT_API int epoll_add_ssock(int eid, SYSSOCKET s, const int* events = NULL);
diff --git a/JavaLauncherApp/src/udt/udtCommon.cpp b/JavaLauncherApp/src/udt/udtCommon.cpp
index 77ebd59..300f2b9 100644
--- a/JavaLauncherApp/src/udt/udtCommon.cpp
+++ b/JavaLauncherApp/src/udt/udtCommon.cpp
@@ -39,11 +39,11 @@ written by
 *****************************************************************************/
 
 
-#ifndef WINDOWS
+#ifndef WIN32
    #include <cstring>
    #include <cerrno>
    #include <unistd.h>
-   #ifdef MACOSX
+   #ifdef OSX
       #include <mach/mach_time.h>
    #endif
 #else
@@ -60,12 +60,12 @@ written by
 
 bool CTimer::m_bUseMicroSecond = false;
 uint64_t CTimer::s_ullCPUFrequency = CTimer::readCPUFrequency();
-#ifndef WINDOWS
-    udt_pthread_mutex_t CTimer::m_EventLock = PTHREAD_MUTEX_INITIALIZER;
-    udt_pthread_cond_t CTimer::m_EventCond = PTHREAD_COND_INITIALIZER;
+#ifndef WIN32
+   pthread_mutex_t CTimer::m_EventLock = PTHREAD_MUTEX_INITIALIZER;
+   pthread_cond_t CTimer::m_EventCond = PTHREAD_COND_INITIALIZER;
 #else
-    udt_pthread_mutex_t CTimer::m_EventLock = CreateMutex(NULL, false, NULL);
-    udt_pthread_cond_t CTimer::m_EventCond = CreateEvent(NULL, false, false, NULL);
+   pthread_mutex_t CTimer::m_EventLock = CreateMutex(NULL, false, NULL);
+   pthread_cond_t CTimer::m_EventCond = CreateEvent(NULL, false, false, NULL);
 #endif
 
 CTimer::CTimer():
@@ -73,7 +73,7 @@ m_ullSchedTime(),
 m_TickCond(),
 m_TickLock()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_mutex_init(&m_TickLock, NULL);
       pthread_cond_init(&m_TickCond, NULL);
    #else
@@ -84,7 +84,7 @@ m_TickLock()
 
 CTimer::~CTimer()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_mutex_destroy(&m_TickLock);
       pthread_cond_destroy(&m_TickCond);
    #else
@@ -101,16 +101,7 @@ void CTimer::rdtsc(uint64_t &x)
       return;
    }
 
-   #if defined(WINDOWS)
-      //HANDLE hCurThread = ::GetCurrentThread();
-      //DWORD_PTR dwOldMask = ::SetThreadAffinityMask(hCurThread, 1);
-      BOOL ret = QueryPerformanceCounter((LARGE_INTEGER *)&x);
-      //SetThreadAffinityMask(hCurThread, dwOldMask);
-      if (!ret)
-         x = getTime() * s_ullCPUFrequency;
-   #elif defined(MACOSX)
-      x = mach_absolute_time();
-   #elif defined(IA32)
+   #ifdef IA32
       uint32_t lval, hval;
       //asm volatile ("push %eax; push %ebx; push %ecx; push %edx");
       //asm volatile ("xor %eax, %eax; cpuid");
@@ -125,6 +116,15 @@ void CTimer::rdtsc(uint64_t &x)
       asm ("rdtsc" : "=a" (lval), "=d" (hval));
       x = hval;
       x = (x << 32) | lval;
+   #elif defined(WIN32)
+      //HANDLE hCurThread = ::GetCurrentThread(); 
+      //DWORD_PTR dwOldMask = ::SetThreadAffinityMask(hCurThread, 1); 
+      BOOL ret = QueryPerformanceCounter((LARGE_INTEGER *)&x);
+      //SetThreadAffinityMask(hCurThread, dwOldMask);
+      if (!ret)
+         x = getTime() * s_ullCPUFrequency;
+   #elif defined(OSX)
+      x = mach_absolute_time();
    #else
       // use system call to read time clock for other archs
       x = getTime();
@@ -135,26 +135,26 @@ uint64_t CTimer::readCPUFrequency()
 {
    uint64_t frequency = 1;  // 1 tick per microsecond.
 
-   #if defined(WINDOWS)
+   #if defined(IA32) || defined(IA64) || defined(AMD64)
+      uint64_t t1, t2;
+
+      rdtsc(t1);
+      timespec ts;
+      ts.tv_sec = 0;
+      ts.tv_nsec = 100000000;
+      nanosleep(&ts, NULL);
+      rdtsc(t2);
+
+      // CPU clocks per microsecond
+      frequency = (t2 - t1) / 100000;
+   #elif defined(WIN32)
       int64_t ccf;
       if (QueryPerformanceFrequency((LARGE_INTEGER *)&ccf))
          frequency = ccf / 1000000;
-   #elif defined(MACOSX)
+   #elif defined(OSX)
       mach_timebase_info_data_t info;
       mach_timebase_info(&info);
       frequency = info.denom * 1000ULL / info.numer;
-   #elif defined(IA32) || defined(IA64) || defined(AMD64)
-     uint64_t t1, t2;
-
-     rdtsc(t1);
-     timespec ts;
-     ts.tv_sec = 0;
-     ts.tv_nsec = 100000000;
-     nanosleep(&ts, NULL);
-     rdtsc(t2);
-
-     // CPU clocks per microsecond
-     frequency = (t2 - t1) / 100000;
    #endif
 
    // Fall back to microsecond if the resolution is not high enough.
@@ -199,7 +199,7 @@ void CTimer::sleepto(uint64_t nexttime)
             __asm__ volatile ("nop; nop; nop; nop; nop;");
          #endif
       #else
-         #ifndef WINDOWS
+         #ifndef WIN32
             timeval now;
             timespec timeout;
             gettimeofday(&now, 0);
@@ -234,7 +234,7 @@ void CTimer::interrupt()
 
 void CTimer::tick()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_cond_signal(&m_TickCond);
    #else
       SetEvent(m_TickCond);
@@ -249,32 +249,32 @@ uint64_t CTimer::getTime()
    //return x / s_ullCPUFrequency;
    //Specific fix may be necessary if rdtsc is not available either.
 
-   #ifndef WINDOWS
+   #ifndef WIN32
       timeval t;
       gettimeofday(&t, 0);
       return t.tv_sec * 1000000ULL + t.tv_usec;
    #else
       LARGE_INTEGER ccf;
-      HANDLE hCurThread = ::GetCurrentThread();
+      HANDLE hCurThread = ::GetCurrentThread(); 
       DWORD_PTR dwOldMask = ::SetThreadAffinityMask(hCurThread, 1);
       if (QueryPerformanceFrequency(&ccf))
       {
          LARGE_INTEGER cc;
          if (QueryPerformanceCounter(&cc))
          {
-            SetThreadAffinityMask(hCurThread, dwOldMask);
+            SetThreadAffinityMask(hCurThread, dwOldMask); 
             return (cc.QuadPart * 1000000ULL / ccf.QuadPart);
          }
       }
 
-      SetThreadAffinityMask(hCurThread, dwOldMask);
+      SetThreadAffinityMask(hCurThread, dwOldMask); 
       return GetTickCount() * 1000ULL;
    #endif
 }
 
 void CTimer::triggerEvent()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_cond_signal(&m_EventCond);
    #else
       SetEvent(m_EventCond);
@@ -283,7 +283,7 @@ void CTimer::triggerEvent()
 
 void CTimer::waitForEvent()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       timeval now;
       timespec timeout;
       gettimeofday(&now, 0);
@@ -307,7 +307,7 @@ void CTimer::waitForEvent()
 
 void CTimer::sleep()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       usleep(10);
    #else
       Sleep(1);
@@ -317,11 +317,11 @@ void CTimer::sleep()
 
 //
 // Automatically lock in constructor
-CGuard::CGuard(udt_pthread_mutex_t& lock):
+CGuard::CGuard(pthread_mutex_t& lock):
 m_Mutex(lock),
 m_iLocked()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       m_iLocked = pthread_mutex_lock(&m_Mutex);
    #else
       m_iLocked = WaitForSingleObject(m_Mutex, INFINITE);
@@ -331,7 +331,7 @@ m_iLocked()
 // Automatically unlock in destructor
 CGuard::~CGuard()
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       if (0 == m_iLocked)
          pthread_mutex_unlock(&m_Mutex);
    #else
@@ -340,54 +340,54 @@ CGuard::~CGuard()
    #endif
 }
 
-void CGuard::enterCS(udt_pthread_mutex_t& lock)
+void CGuard::enterCS(pthread_mutex_t& lock)
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_mutex_lock(&lock);
    #else
       WaitForSingleObject(lock, INFINITE);
    #endif
 }
 
-void CGuard::leaveCS(udt_pthread_mutex_t& lock)
+void CGuard::leaveCS(pthread_mutex_t& lock)
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_mutex_unlock(&lock);
    #else
       ReleaseMutex(lock);
    #endif
 }
 
-void CGuard::createMutex(udt_pthread_mutex_t& lock)
+void CGuard::createMutex(pthread_mutex_t& lock)
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_mutex_init(&lock, NULL);
    #else
       lock = CreateMutex(NULL, false, NULL);
    #endif
 }
 
-void CGuard::releaseMutex(udt_pthread_mutex_t& lock)
+void CGuard::releaseMutex(pthread_mutex_t& lock)
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_mutex_destroy(&lock);
    #else
       CloseHandle(lock);
    #endif
 }
 
-void CGuard::createCond(udt_pthread_cond_t& cond)
+void CGuard::createCond(pthread_cond_t& cond)
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_cond_init(&cond, NULL);
    #else
       cond = CreateEvent(NULL, false, false, NULL);
    #endif
 }
 
-void CGuard::releaseCond(udt_pthread_cond_t& cond)
+void CGuard::releaseCond(pthread_cond_t& cond)
 {
-   #ifndef WINDOWS
+   #ifndef WIN32
       pthread_cond_destroy(&cond);
    #else
       CloseHandle(cond);
@@ -401,7 +401,7 @@ m_iMajor(major),
 m_iMinor(minor)
 {
    if (-1 == err)
-      #ifndef WINDOWS
+      #ifndef WIN32
          m_iErrno = errno;
       #else
          m_iErrno = GetLastError();
@@ -524,7 +524,7 @@ const char* CUDTException::getErrorMessage()
 
       case 5:
         m_strMsg = "Operation not supported";
-
+ 
         switch (m_iMinor)
         {
         case 1:
@@ -617,7 +617,7 @@ const char* CUDTException::getErrorMessage()
    if ((0 != m_iMajor) && (0 < m_iErrno))
    {
       m_strMsg += ": ";
-      #ifndef WINDOWS
+      #ifndef WIN32
          char errmsg[1024];
          if (strerror_r(m_iErrno, errmsg, 1024) == 0)
             m_strMsg += errmsg;
@@ -630,7 +630,7 @@ const char* CUDTException::getErrorMessage()
    }
 
    // period
-   #ifndef WINDOWS
+   #ifndef WIN32
       m_strMsg += ".";
    #endif
 
diff --git a/JavaLauncherApp/src/udt/udtCommon.h b/JavaLauncherApp/src/udt/udtCommon.h
index 15225ec..3ecf846 100644
--- a/JavaLauncherApp/src/udt/udtCommon.h
+++ b/JavaLauncherApp/src/udt/udtCommon.h
@@ -42,31 +42,27 @@ written by
 #define __UDT_COMMON_H__
 
 
-#ifndef WINDOWS
+#ifndef WIN32
    #include <sys/time.h>
    #include <sys/uio.h>
    #include <pthread.h>
 #else
-   #include <stdint.h>
-   #include <winsock2.h>
-   #include <ws2tcpip.h>
+   #ifdef __MINGW__
+      #include <stdint.h>
+      #include <ws2tcpip.h>
+   #endif
    #include <windows.h>
 #endif
 #include <cstdlib>
 #include "udt.h"
 
 
-#ifdef WINDOWS
-    // Windows compatibility
-    typedef HANDLE udt_pthread_t;
-    typedef HANDLE udt_pthread_mutex_t;
-    typedef HANDLE udt_pthread_cond_t;
-    typedef DWORD udt_pthread_key_t;
-#else
-    typedef pthread_t udt_pthread_t;
-    typedef pthread_mutex_t udt_pthread_mutex_t;
-    typedef pthread_cond_t udt_pthread_cond_t;
-    typedef pthread_key_t udt_pthread_key_t;
+#ifdef WIN32
+   // Windows compability
+   typedef HANDLE pthread_t;
+   typedef HANDLE pthread_mutex_t;
+   typedef HANDLE pthread_cond_t;
+   typedef DWORD pthread_key_t;
 #endif
 
 
@@ -178,11 +174,11 @@ private:
 private:
    uint64_t m_ullSchedTime;             // next schedulled time
 
-   udt_pthread_cond_t m_TickCond;
-   udt_pthread_mutex_t m_TickLock;
+   pthread_cond_t m_TickCond;
+   pthread_mutex_t m_TickLock;
 
-   static udt_pthread_cond_t m_EventCond;
-   static udt_pthread_mutex_t m_EventLock;
+   static pthread_cond_t m_EventCond;
+   static pthread_mutex_t m_EventLock;
 
 private:
    static uint64_t s_ullCPUFrequency;	// CPU frequency : clock cycles per microsecond
@@ -195,22 +191,22 @@ private:
 class CGuard
 {
 public:
-   CGuard(udt_pthread_mutex_t& lock);
+   CGuard(pthread_mutex_t& lock);
    ~CGuard();
 
 public:
-   static void enterCS(udt_pthread_mutex_t& lock);
-   static void leaveCS(udt_pthread_mutex_t& lock);
+   static void enterCS(pthread_mutex_t& lock);
+   static void leaveCS(pthread_mutex_t& lock);
 
-   static void createMutex(udt_pthread_mutex_t& lock);
-   static void releaseMutex(udt_pthread_mutex_t& lock);
+   static void createMutex(pthread_mutex_t& lock);
+   static void releaseMutex(pthread_mutex_t& lock);
 
-   static void createCond(udt_pthread_cond_t& cond);
-   static void releaseCond(udt_pthread_cond_t& cond);
+   static void createCond(pthread_cond_t& cond);
+   static void releaseCond(pthread_cond_t& cond);
 
 private:
-   udt_pthread_mutex_t& m_Mutex;            // Alias name of the mutex to be protected
-   unsigned int m_iLocked;                  // Locking status
+   pthread_mutex_t& m_Mutex;            // Alias name of the mutex to be protected
+   int m_iLocked;                       // Locking status
 
    CGuard& operator=(const CGuard&);
 };
-- 
1.9.1

