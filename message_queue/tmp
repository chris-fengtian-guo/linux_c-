class BtTaskManager {
public:
    BtTaskManager() : next_task_uuid_(0) {}

    unsigned int addTask(unsigned int bt_id, std::function<void()> task_func) {
        std::unique_lock<std::mutex> lock(tasks_mutex_);

        BtTaskStatus status;
        status.task_uuid = next_task_uuid_;
        status.bt_id = bt_id;
        status.status = NOT_RUNNING;
        
        std::thread task_thread([this, task_func, task_uuid = status.task_uuid]() {
            {
                std::unique_lock<std::mutex> lock(tasks_mutex_);
                task_added_cv_.wait(lock, [this, task_uuid]() { 
                    return tasks_.find(task_uuid) != tasks_.end(); 
                });
            }
            task_func();
        });
        
        status.thread_id = task_thread.get_id();
        threads_[status.task_uuid] = std::move(task_thread);
        tasks_[status.task_uuid] = status;
        
        task_added_cv_.notify_all();
        
        return next_task_uuid_++;
    }

    // ...

private:
    unsigned int next_task_uuid_;
    std::map<unsigned int, BtTaskStatus> tasks_;
    std::map<unsigned int, std::thread> threads_;
    std::mutex tasks_mutex_;
    std::condition_variable task_added_cv_;
};
